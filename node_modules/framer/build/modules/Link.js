import React from "react";
import { findAnchorElement } from "../render/utils/findAnchorElement.js";
import { getPathForRoute, inferInitialRouteFromPath, preloadComponent, useCurrentRoute, useRouter, } from "../router/index.js";
import { assert } from "../utils/assert.js";
import { isFramerPageLink, linkMatchesRoute, parseFramerPageLink, useImplicitPathVariables } from "./framerPageLink.js";
function isInternalURL(href) {
    if (href === undefined)
        return false;
    if (href.startsWith("#") || href.startsWith("/") || href.startsWith("."))
        return true;
    return false;
}
function isValidURL(href, isInternal) {
    try {
        const url = new URL(href);
        return Boolean(url.protocol); // in theory this should always be true, but just in case?
    }
    catch {
        // Ignore thrown errors.
    }
    return isInternal;
}
/**
 * @internal
 */
export var AnchorLinkTarget;
(function (AnchorLinkTarget) {
    AnchorLinkTarget["_blank"] = "_blank";
    AnchorLinkTarget["_self"] = "_self";
})(AnchorLinkTarget || (AnchorLinkTarget = {}));
/**
 * @internal
 */
export function isValidAnchorLinkTargetValue(value) {
    if (value === undefined)
        return true;
    return value === AnchorLinkTarget._blank || value === AnchorLinkTarget._self;
}
/**
 * @internal
 */
export function inferDefaultLinkTarget(link) {
    if (!link)
        return undefined;
    return isFramerPageLink(link) ? AnchorLinkTarget._self : AnchorLinkTarget._blank;
}
function getTargetAttrValue(openInNewTab, isInternal) {
    if (openInNewTab !== undefined) {
        // `_self` is the browser default, we can just omit the attribute
        return openInNewTab ? AnchorLinkTarget._blank : undefined;
    }
    // If the target prop is not set, fallback to the default behavior based on the link
    return isInternal ? undefined : AnchorLinkTarget._blank;
}
export function propsForLink(href, openInNewTab = undefined) {
    const isInternal = isInternalURL(href);
    const anchorTarget = getTargetAttrValue(openInNewTab, isInternal);
    return {
        href: isValidURL(href, isInternal) ? href : `https://${href}`,
        target: anchorTarget,
        rel: !isInternal ? "noreferrer noopener" : undefined,
    };
}
function propsForRoutePath(href, openInNewTab, router, currentRoute, implicitPathVariables, smoothScroll) {
    const isInternal = isInternalURL(href);
    if (!router.routes || !router.getRoute || !currentRoute || !isInternal) {
        return propsForLink(href, openInNewTab);
    }
    try {
        const [pathname, hash] = href.split("#", 2);
        assert(pathname !== undefined, "A href must have a defined pathname.");
        const { routeId, pathVariables } = inferInitialRouteFromPath(router.routes, pathname);
        const route = router.getRoute(routeId);
        if (route) {
            preloadComponent(route.page);
            // Hash will be "" if there isn't one. Coerce that
            // to undefined to satisfy the API.
            const elementId = hash || undefined;
            const combinedPathVariables = Object.assign({}, implicitPathVariables, pathVariables);
            // Make the link relative to the current path if we can.
            const path = getPathForRoute(route, {
                currentRoutePath: currentRoute.path,
                elementId,
                pathVariables: combinedPathVariables,
            });
            const anchorTarget = getTargetAttrValue(openInNewTab, true);
            return {
                href: path,
                target: anchorTarget,
                onClick(event) {
                    /**
                     * Note: in the preview iframe we hijack all anchor link
                     * clicks and modify the target based on the href, so that
                     * we won't try to open an external links in the preview
                     * iframe, for example. (see PreviewRenderer.tsx)
                     */
                    // We don't need SPA routing when opening links in a new tab
                    const anchorElement = findAnchorElement(event.target);
                    if (!anchorElement || anchorElement.getAttribute("target") === AnchorLinkTarget._blank)
                        return;
                    event.preventDefault();
                    router.navigate?.(routeId, elementId, combinedPathVariables, smoothScroll);
                },
            };
        }
    }
    catch {
        // Fall through, we could not match the path to a path defined in our
        // routes. We will assume the href is an external link.
    }
    return propsForLink(href, openInNewTab);
}
/** @public */
export const Link = React.forwardRef(({ children, href, openInNewTab, smoothScroll, ...restProps }, forwardedRef) => {
    const router = useRouter();
    const currentRoute = useCurrentRoute();
    const implicitPathVariables = useImplicitPathVariables();
    const props = React.useMemo(() => {
        if (!href)
            return {};
        const pageLink = parseFramerPageLink(href);
        if (!pageLink) {
            return propsForRoutePath(href, openInNewTab, router, currentRoute, implicitPathVariables, smoothScroll);
        }
        if (!pageLink.target) {
            return {};
        }
        const routeId = pageLink.target;
        const elementId = pageLink.element ?? undefined;
        const route = router.getRoute?.(routeId);
        if (route)
            preloadComponent(route.page);
        const pathVariables = Object.assign({}, implicitPathVariables, pageLink.collectionItem?.pathVariables);
        const anchorTarget = getTargetAttrValue(openInNewTab, true);
        return {
            href: getPathForRoute(route, {
                currentRoutePath: currentRoute?.path,
                elementId,
                pathVariables,
            }),
            target: anchorTarget,
            onClick(event) {
                // We don't need SPA routing when opening links in a new tab
                const anchorElement = findAnchorElement(event.target);
                if (!anchorElement || anchorElement.getAttribute("target") === AnchorLinkTarget._blank)
                    return;
                // If command is pressed when clicking a link we want to open a new tab instead
                if (event.metaKey)
                    return;
                event.preventDefault();
                router.navigate?.(routeId, elementId, pathVariables, smoothScroll);
            },
            "data-framer-page-link-current": (currentRoute && linkMatchesRoute(currentRoute, pageLink, implicitPathVariables)) || undefined,
        };
    }, [currentRoute, href, openInNewTab, implicitPathVariables, router, smoothScroll]);
    if (!children)
        return null;
    const child = React.Children.only(children);
    if (!React.isValidElement(child))
        return null;
    return React.cloneElement(child, { ...restProps, ...props, ref: forwardedRef });
});
/** @public */
export function resolveLink(href, router, implicitPathVariables) {
    // Parsing framer page links means this function is stuck in library.
    const pageLink = parseFramerPageLink(href);
    if (!pageLink || !pageLink.target)
        return propsForLink(href).href;
    if (!router.getRoute || !router.currentRouteId)
        return href;
    const currentRoute = router.getRoute(router.currentRouteId);
    const routeId = pageLink.target;
    const elementId = pageLink.element ?? undefined;
    const route = router.getRoute(routeId);
    const pathVariables = Object.assign({}, router.currentPathVariables, implicitPathVariables, pageLink.collectionItem?.pathVariables);
    return getPathForRoute(route, { currentRoutePath: currentRoute?.path, elementId, pathVariables, relative: false });
}
//# sourceMappingURL=Link.js.map